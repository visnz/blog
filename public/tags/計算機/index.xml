<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>計算機 on * IN SHADOW</title>
    <link>/tags/%E8%A8%88%E7%AE%97%E6%A9%9F/</link>
    <description>Recent content in 計算機 on * IN SHADOW</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Dec 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/%E8%A8%88%E7%AE%97%E6%A9%9F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Systemd 扎記</title>
      <link>/post/systemd/</link>
      <pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/systemd/</guid>
      <description>簡述 # sell my underpant to systemd #
 systemd(System Daemon, 系統守護進程)：是一個Linux的系統與服務管理器，由systemctl進行控制，支援系統快照與回復系統狀態，支持自動掛載等。已完美取代sysvinit
 系統啓動過程：
 BIOS/UEFI啓動 GRUB引導啓動 尋找/boot(GSP分區)並載入內核 CPUIDLE與內核初始化(PID=0) /sbin/init（systemd啓動，PID=1） fork啓動systemd註冊的基層服務  不同進程工具檢出PID=1的進程不一樣，systemd（pstree -Apn檢出結果）或是/sbin/init（ps -aux檢出結果）
$ ls -al /sbin/init lrwxrwxrwx 1 root root 22 Nov 26 21:35 /sbin/init -&amp;gt; ../lib/systemd/systemd   基本使用  systemctl：進入主界面
 systemctl --failed查看启动失败的单元
 systemctl start/enable/disable/stop/restart/mask/unmask &amp;lt;Unit&amp;gt;：相應地對一個unit進行操作
 systemctl daemon-reload：掃描新的有變動的單元，通常更新配置後需要使用
 圖形化管理界面：systemd-ui
 遠程管理：systemctl -H root@example
 systemctl list-unit-files --type=service：列出可用單元及其情況（指定service類型）
 systemd-*系列也提供了許多方便實用的工具
 systemd-analyze blame：分析啓動時花費的時間</description>
    </item>
    
    <item>
      <title>Linux 筆記大整理 &amp; 工具備忘錄</title>
      <link>/post/linux/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/linux/</guid>
      <description>基本工具  df、fdisk、fdisk等基本硬盤查看工具
 ls：基本是自帶--color=auto這個地燈設置。
 -al列出隱藏與詳細信息
 -Csh着色、大小顯示
 -R超詳細目錄信息
  tty查看当前 tty 终端=&amp;gt;/dev/pts/*，可以用于重定向输出
 init * runlevel
 &amp;amp;丢后台
 后台任务检查jobs任务管理器top/htop、ps -ax
 内存检查free
 端口占用检查netstat -anp|grep [port]、lsof -i
 变量修改：export LANG=zh_CN.UTF-8变量追加：export LANG=$LANG:en_US.UTF-8
 sudo组：echo &amp;quot;%sudoer ALL=(ALL:ALL) ALL&amp;quot;&amp;gt;&amp;gt; /etc/sudoers
 dd if=* of=* bs=1M count=200
 查看查找：file、type、whereis
 locate：查找，使用 mlocate 包，使用 updatedb 更新数据库
 chattr設置文件安全屬性（lsattr現實）
 A atime訪問時間不會因爲訪問而修改（隱藏讀取痕跡）
 S 數據立即寫入，不參與緩存（適合重要數據寫入，防止斷電丟失）
 a append追加寫入權限（適用於log、passwd文件）
 c 壓縮加密文件，以時間換空間（長時間一次的大文件讀寫存儲等）</description>
    </item>
    
    <item>
      <title>VSCode記 Gists同步部署生產環境(Atom&amp;Vim)</title>
      <link>/post/gists/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/gists/</guid>
      <description>問題描述  擁有不止一個生產環境，而且這些生產環境也不一定持久的情況下（隨時有可能一鍵重裝、部署新機器），不同生產環境要求有相同的配置（同步需求）
 有隨時隨地看到好 extensions 就想 install 的壞習慣
 作為生產力工具，需要快速、自動化、可管理的部署以減少不必要損失（包括不限於擴展配置）
  解決 使用較為小型的私人代碼在線託管服務（大型網路里專門用於管理配置的配置服務器），將配置代碼上傳託管，按需獲取。有安全需求可自建機器與認證。
VSCode VSCode 中有一個提供 Setting Sync Anywhere 的擴展，使用 Github 提供的 Gists 服務，短代碼在線託管（允許版本管理）
Setting Sync 基本步驟如下：
 github里生成gist token（用於身份分離認證 複製保存好）
 vscode中使用setting sync擴展進行同步：upload，產生一個公開的以Username、gistID為依據的網頁（每次更新配置都會產生新的gistID，注意保存）
 獲取gist ID（可以在github gists 服務里找到URL最後一個便是），同步的時候使用gistID、token獲得
  詳細操作步驟參考
Atom Atom裏也有支持設置同步的sync-settings
apm install sync-setting
也需要提供gist token 不過需要自己手動在gists上創建一個gist
將gistID在設置中設置
vim vim方面寫了個js腳本來完成下載 上傳就懶得寫了直接webpage edit一下得了（懶
const https=require(&amp;quot;https&amp;quot;) const fs = require(&#39;fs&#39;); const gistID=&amp;quot;------------------------------------&amp;quot; const remoteFilename=&amp;quot;--------------&amp;quot; const filepath=&amp;quot;------------------------&amp;quot; download(gistID,remoteFilename,filepath) //提供指定gistID，遠程文件名（嗯目前只支持了一個），以及保存的地方 function download(gistID,remoteFilename,filepath){ //調用github api，獲取指定gist的相關信息 //需要附上headers https.</description>
    </item>
    
  </channel>
</rss>