/*
  wifi:    PingingLab-Redhat
  密码:  pinginglabredhat123
  QQ:510168860
  微信号:lkmeeqfn1989
  手机:18520783488

  linux:

  上课用到的软件:
      sublime text 3
      vmware workstation
      xshell / putty #终端软件

  常用的国外Linux资源：
    lwn.net 来自Linux和开放源代码界的新闻
    www.freshmeat.net 最齐全的Linux/UNIX软件库
    www.justlinux.com 信息最全的Linux学习网站
    www.kernel.org Linux 内核的官方网站
    www.linux.com 提供全方位的Linux信息
    www.linuxhq.com 提供内核信息和补丁的汇总
    www.linuxtoday.com 非常完整的Linux新闻站点

  国内的Linux的资源
    www.chinaunix.net 国内最大的Linux/UNIX技术社区网站
    www.linuxeden.com Linux伊甸园，最大的中文开源资讯门户网站
    www.linuxfans.org 中国Linux公社，拥有自己的Linux发行版本Magic Linux
    www.linuxsir.org 提供各种Linux资源、包括资讯、软件、手册等

  学习方法:
      mindmanager
      为知笔记
  学好linux:
      练习
*/
1.Introduction (介绍){
  起源(来源于wiki"https://zh.wikipedia.org/wiki/Linux"){
    Linux（/ˈlɪnəks/LIN-əks）是一種自由和開放源碼的類UNIX作業系統。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。在加上使用者空間的應用程式之後，成為Linux作業系統。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循GNU通用公共许可证，任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。大多數Linux系統還包括像提供GUI的XWindow之類的程序。除了一部分專家之外，大多數人都是直接使用Linux發行版，而不是自己選擇每一樣組件或自行設置。

    严格来讲，术语Linux只表示操作系统内核本身，但通常采用Linux内核来表达该意思。Linux则常用来指基于Linux内核的完整操作系统，包括GUI组件和许多其他实用工具。由于这些支持用户空间的系统工具和库主要由理查德·斯托曼于1983年发起的GNU计划提供，自由软件基金会提议将该组合系统命名为GNU/Linux，但Linux不屬於GNU計劃。

    Linux最初是作为支持英特尔x86架构的个人电脑的一个自由操作系统。目前Linux已经被移植到更多的计算机硬件平台，远远超出其他任何操作系统。Linux可以运行在服务器和其他大型平台之上，如大型主机和超级计算机。世界上500个最快的超级计算机90％以上运行Linux发行版或变种，包括最快的前10名超级电脑运行的都是基于Linux内核的操作系统。Linux也广泛应用在嵌入式系统上，如手机（MobilePhone）、平板电脑（Tablet）、路由器（Router）、电视（TV）和电子游戏机等。在移动设备上广泛使用的Android操作系统就是建立在Linux内核之上。

    通常情况下，Linux被打包成供个人计算机和服务器使用的Linux发行版，一些流行的主流Linux发布版，包括Debian（及其派生版本Ubuntu、Linux Mint）、Fedora（及其相关版本Red Hat Enterprise Linux、CentOS）和openSUSE等。Linux发行版包含Linux内核和支撑内核的实用程序和库，通常还带有大量可以满足各类需求的应用程序。个人计算机使用的Linux发行版通常包含XWindow和一个相应的桌面环境，如GNOME或KDE。桌面Linux操作系统常用的应用程序，包括Firefox网页浏览器、LibreOffice办公软件、GIMP图像处理工具等。由于Linux是自由软件，任何人都可以创建一个符合自己需求的Linux发行版。

    UNIX(){
      UNIX操作系统（英语：UNIX），是美国AT&T公司贝尔实验室于1969年完成的操作系统。最早由肯·湯普遜（Ken Thompson），丹尼斯·里奇（Dennis Ritchie），道格拉斯·麥克羅伊（Douglas McIlroy），和喬伊·歐桑納于1969年在AT&T贝尔实验室开发。于1971年首次发布，最初是完全用汇编语言编写，这在当时是一种普遍的做法[來源請求]。后来，在1973年用一个重要的开拓性的方法，Unix被丹尼斯·里奇用编程语言C（内核和I/O例外）重新编写。高级语言编写的操作系统具有更佳的兼容性，能更容易地移植到不同的计算机平台。
    }

    GNU(){
      1983年，理查德·馬修·斯托曼創立GNU計劃。這個計劃有一個目標，是為了發展一個完全自由的類Unix作業系統。自1984年發起這個計劃以來，在1985年，理查德·馬修·斯托曼發起自由軟體基金會並且在1989年撰寫GPL。1990年代早期，GNU開始大量的產生或收集各種系統所必備的元件，像是——函式庫、編譯器、偵錯工具、文字編輯器、網頁伺服器，以及一個Unix的使用者介面（Unix shell）——但是像一些底層環境，如硬體驅動、守護進程執行核心（kernel）仍然不完整和陷于停顿，GNU計劃中是在馬赫微核（Mach microkernel）的架構之上開發系統核心，也就是所謂的GNU Hurd，但是這個基於Mach的設計異常複雜，發展進度則相對緩慢。林納斯·托瓦茲曾說過如果GNU核心在1991年時可以用，他不會自己去寫一個。
    }

    Linux(){
      在1991年，林納斯·托瓦茲開始在MINIX上開發Linux內核，為MINIX寫的軟體也可以在Linux內核上使用。[18]后来使用GNU軟體代替MINIX的軟體，因為使用從GNU系統來的原始碼可以自由使用，這對Linux的发展是有益。使用GNU_GPL協議的原始碼可以被其他項目所使用，只要這些項目使用同樣的協議發布。為了讓Linux可以在商業上使用，林納斯·托瓦茲決定更改他原來的協議（這個協議會限制商業使用），以GNU_GPL協議來代替。之后许多開發者致力融合GNU元素到Linux中，做出一個有完整功能的、自由的作業系統。

      第一個版本的Linux在1991年9月被大學FTP_server管理員Ari_Lemmke發佈在Internet上，最初Torvalds稱這個核心的名稱為"Freax"，意思是自由（"free"）和奇異（"freak"）的結合字，並且附上"X"這個常用的字母，以配合所謂的類Unix的系統。但是FTP伺服器管理員嫌原來的命名「Freax」的名稱不好聽，把核心的稱呼改成「Linux」，當時僅有10000行程式碼，仍必須執行於Minix作業系統之上，並且必須使用硬碟開機；隨後在10月份第二個版本（0.02版）發佈，同時這位芬蘭赫爾辛基的大學生在comp.os.minix上發佈一則訊息

        Hello everybody out there using minix- I'm doing a (free) operation system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones.

      1994年3月，Linux1.0版正式發佈，Marc Ewing成立Red Hat軟件公司，成為最著名的Linux經銷商之一。

      早期Linux的開機管理程式（boot loader）使用LILO（Linux Loader），早期的LILO存在著一些難以容忍的缺陷，例如無法識別1024柱面以後的硬碟空間，後來的GRUB（GRand Unified Bootloader）克服這些缺點，具有『動態搜尋核心檔案』的功能，可以讓用户在開機的時候，自行編輯開機設定系統檔案，透過ext2或ext3檔案系統中載入Linux Kernel（GRUB通過不同的文件系統驅動可以識別幾乎所有Linux支援的文件系統，因此可以使用很多文件系統來格式化核心文件所在的磁區，並不侷限於ext文件系統）。

      Linux的標誌和吉祥物是一隻名字叫做Tux的企鵝，標誌的由來是因為Linus在澳洲時曾被一隻動物園裡的企鵝咬了一口，便選擇企鵝作為Linux的標誌。更容易被接受的說法是：企鵝代表南極，而南極又是全世界所共有的一塊陸地。這也就代表Linux是所有人的Linux。
    }
  }
  发展现状(同源){
    今天由Linus_Torvalds带领下，众多开发共同参与开发和维护Linux内核。理查德·斯托曼领导的自由软件基金会，继续提供大量支持Linux内核的GNU组件。一些个人和企业开发的第三方的非GNU组件也提供对Linux内核的支持，这些第三方组件包括大量的作品，有内核模块和用户应用程序和库等内容。Linux社区或企业都推出一些重要的Linux发行版，包括Linux内核、GNU组件、非GNU组件，以及其他形式的的软件包管理系统软件。
  }
  系统架构(同源){
    基于Linux的系统是一个模块化的类Unix操作系统。Linux操作系统的大部分设计思想来源于20世纪70年代到80年代的Unix操作系统所建立的基本设计思想。Linux系统使用单内核，由Linux内核负责处理进程控制、网络，以及外围设备和文件系统的访问。在系统运行的时候，设备驱动程序要么与内核直接整合，要么以加载模块形式添加。

    Linux具有设备独立性，它内核具有高度适应能力，从而给系统提供了更高级的功能。GNU用户界面组件是大多数Linux操作系统的重要组成部分，提供常用的C函数库，shell，还有许多常见的Unix实用工具，可以完成许多基本的操作系统任务。大多数Linux系统使用的图形用户界面建立在X窗口系统之上，由X窗口(XWindows)系统通过软件工具及架构协议来建立操作系统所用的图形用户界面。

    已安装Linux操作系统包含的一些组件：

    启动程序——例如GRUB或LILO。该程序在计算机开机启动的时候运行，并将Linux内核加载到内存中。

    init程序。init是由Linux内核创建的第一个进程，称为根进程，所有的系统进程都是它的子进程，即所有的进程都是通过init启动。init启动的进程如系统服务和登录提示（图形或终端模式的选择）。

    软件库包含代码，可以通过运行的进程。在Linux系统上使用ELF格式来执行文件，负责管理库使用的动态链接器是“ld-linux.so”。Linux系统上最常用的软件库是GNU C库。

    用户界面程序，如命令行shell或窗口环境。
  }
  class Unix{
    IBM: AIX
      HP: HPUNIX
      SUN: SUNOS
  }
  class System{
    硬件
    软件
      Kernel内核:内存管理,进程调度,文件系统,I/O管理等
      Shell外壳:用户与内核交互的一个接口
      其他应用
      linux两大编辑器:
        emacs
        vi(vim)
      GNU(GNU is Not UNIX)
      GPL(GNU Public Liscence)
  }
  class LinuxOS{
    发行版本(){
      Redhat体系(CentOS,Fedora,EHEL)//版本号为7的有重大变更
      Debian体系(Ubuntu,Raspbin)
      Others(AOSC,ArchLinux)
    }
    区别(){
      filestructure软件包管理(){
        Redhat:
          rpm   .rpm
          yum//使用yum解决依赖性问题

        Debian:
          dpkg(Debian PacKaGe)    .deb
          apt-get//使用Apt-get解决依赖性问题(用作服务器系统)

      MainIdea:"Everything is file"//一切皆文件
      }
    }
  }
}

2.Installation (安装){
  class Linuxdisk{
      常见问题(){
        从哪里获得linux:从各个官方网站下载，如果下载速度慢的话可以选取国内的源(mirros)

        哪种发行版最好:并没有这种答案，想使用学习成本低的话可以选择ubuntu及其衍生版本，企业安全的话愿意出系统维护费用就Redhat，省钱就Centos，最求最简单的系统的话就ArchLinux。总之选择很多样。另外有时候操作习惯会对一个操作系统的好坏产生影响，比如说有些默认自带的KDE桌面环境会导致一些人操作不适应。

        最低要求配置是多少:各个版本对应的设备要求不一样，桌面环境也会对设备的要求有影响，但是对于大多数的linux发行版而言对电脑的要求都不会很高，部分比较新的linux只支持64位CPU。

        Linux会不会覆盖我原有的windows操作系统:只要安装在不同于windows的空白分区上就不会影响

        Windows装好了linux不见了:先有windows后有天(玄学)，实际上是windows自作聪明在安装的时候吧多重引导程序Grub覆盖了，解决的方法就是重新安装Grub。当然前提是有一张相同版本的linux安装光盘或者U盘(老机器不一定支持UEFI启动，所以在下文中不提)，一些linux发行版本(比如ArchLinux)在安装光盘中包含了"救援模式"，在这个模式下用户可以令以root身份登陆到系统而不需要提供口令。另外一些发行版本(比如Ubuntu)在安装光盘中提供了LiveCD功能，即用户可以通过CD运行完整的操作系统，这些发行版也不需要"救援模式"了因为其本身就是一张恢复光盘。同时在LiveCD上的任何操作都不会改变计算机中的内容(文件都放在RAM中)，除非通过CD安装操作系统。成功的从光盘启动之后就已经做好了修复Grub的准备，我们需要依次输入以下命令(){
          grub                    //启动光盘上的Grub程序，如果是在使用LiveCD的话要加上 sudo 提高权限
          find /boot/grub/stage1  //查找硬盘上的linux系统将/boot目录存放在哪个硬盘分区中。安装时需要读取这个目录中的相关配置文件
          root (hdx,y)            //指示linux内核文件所在的硬盘分区(也就是/boot目录所在的分区)，将这里的(hdx,y)替换为上一行中查找到的那个分区。注意这个括号内不能存在空格。
          setup (hd0)             //在第一块硬盘上安装引导程序Grub
          quit                    //退出Grub程序
        }                         //注意Grub不区分IDE、SCSI、SATA，统一标识为hd#

        虚拟机上的操作会不会对原本的系统产生影响:表示还没有遇到过，除非电脑性能不足死机了。

        虚拟机与校园网冲突:禁用虚拟机网卡，然后在配置的时候选择桥接(NAT)模式，剩下的因为各种虚拟机的设置方式不一样，只能自己多试试了。实体安装的话可以直接下载linux版本的客户端。

        我没有设置树莓派的密码该如何登录:默认账号密码:pi raspberry 之后可以用passwd命令(临时获得root权限sudo)设置或者改写密码，另外还可以设置新用户，比如root用户。

        命令不会用怎么办:一般--help 详细的则man [COMMAND]

        root能做什么:什么都可以做，所以在使用root权限的时候要慎重行事，不要傻呵呵的"rm -fr /*"然后系统会很乐意的把自己完完整整的删除。有时候又必须用到root权限，所以一般都用sudo 临时调用root权限(仅限当前命令行)。对于绝大多数的linux发行版而言，安装的最后一步会设置两个用户口令:一个是root用户一个是用于登陆系统的普通用户。而对于Debian和Ubuntu而言，他们只设置一个普通用户而这个普通用户在某种程度上又充当了root。

        普通用户调用sudo和root用户直接使用命令有什么区别:sudo 通过读取/etc/sudoers 来确定用户是否可以执行相关命令，而这个文件默认需要有root权限才能修改。也即是root用户可以通过修改该文件来限定普通用户的权限。当然对于以普通用户身份登陆的管理员可以通过sudo -s [name]也即是 su [name]来提升为root用户。随后会要求输入root用户的密码。由于安全性考虑所以在输入密码的时候屏幕上不会有任何提示。最后可以用"exit"命令回到普通用户权限。

        我的Ubuntu没有中文:多数linux发行版在安装的时候选择中文支持就可以了，但Ubuntu用户需要在安装过程结束后安装中文包。安装过程如下(新版本的Ubuntu可能有所不同){
          sudo apt-get update //更新，当然可以在更新之前去更换速度更快的源
          选择"系统(System)"|"系统管理"|"语言支持(Language Support)"命令，打开语言支持对话框
          从Supported Languages 列表中选择"汉语"选项，并且单击"OK",系统会要求用户确认安装信息。
          单击"Apply"接受并执行安装。
          安装完成后重启就可以让Ubuntu全方位的支持中文了。
        }

        关于硬件驱动问题:早期的Linux比较幸酸，需要系统管理员自己寻找硬件驱动，有时候不得不自己编写。而现在的Linux已经得到了绝大部分主流硬件厂商的支持。在Linux安装完成后，往往已经不需要再安装什么驱动程序了。Linux 安装程序会自动检测系统硬件，并且安装相应的驱动程序。这一点比早期的Windows做的甚至更好，不然也不会有驱动精灵一说。

        是否要安装系统更新:是，为了稳定而不去更新，这对于任何一个系统来说都是邪教。、

        桌面环境KDE 好还是GNOME 好:简单来说KDE 在外观上看起来更加漂亮，而GNOME 则是更为精简干脆，二者孰优孰劣取决于用户对性能和外观之间的权衡。指的一提的是KDE 是用C++编写的，基于Qt库。而GNOME是基于C语言写的，基于GTK+widget库。

        怎样打开命令行:一般来说在开始菜单内可以找到，或者自行设置快捷键，也可以使用命令行控制台。Linux 默认有7个控制台，可以通过按快捷键"Ctrl+Alt+F1~F7"进入。默认情况下前6个控制台是命令行控制台，第7个则留个X 服务器。

        命令是否像Windows下一样，不区分大小写:不，Linux 严格区分大小写，例如SUDO 和sudo 是不一样的。
      }
      安装方式(){
        CD-ROM(光盘镜像安装)
        USB(U盘安装)
        NET(网络引导安装)
      }
      设备在linux中的名称(){
        IDE硬盘          /dev/hda   hdb  hdc ...
        sata,u盘     /dev/sda   sdb  sdc ...
                     //分区文件 sda1 sda2 sda3
        cdrom        /dev/cdrom ---> /dev/sr0
                     //每个扇区512bytes
      }
      Linux储存设备(){
        IDE     //DIR:/dev/hd?
        SATA    //DIR:/dev/sd?
        CD-ROM  //dir:/dev/cdrom
      }
      Linux硬盘分区格式(){
        MBR:1.最多支持四个主分区//可在第四分区继续创建逻辑分区
            2.最多2TB
            3.多用于Linux/Window
        GPT:1.最多支持128分区
            2.最多支持18EB
            3.需要有UEFI启动支持的硬件
        /*
        1EB=1024PB
        1PB=1024GB
        1GB=1024MB
        */
      }
      Linux分区(){
        1./boot   //内核
        2./       //slash 根目录
        3./swap   //内存不足时可以使用的虚拟内存(RAM>2G swap=2G, RAM<2G swap=2*RAM)
      }
      格式化类型(mkfs制作文件系统){
        Windows:NTFS/FAT32
        Linux:EXT3/EXT4/XFS
      }
      桌面包(图形化环境){
        GNOME
        KDE
        XFCE
      }
  }

  class configuration(配置){
      配置Grub(Grub启动时从 /boot/grub/menu.lst读取引导配置){
        title Linux                         //引导时显示的标题，用户可更改，但是不建议更改
        root (hd0,1)                        //指定了从哪个硬盘分区开始引导(即根分区)。这里表示第一个硬盘的第二个主分区
        kernel /vmlinuz root=/dev/hda2 ro   //指定了Linux内核所在的位置

        /*
          title Windows 95/98/NT/2000       //这是取自Windows系统的Grub
          root (hd0,0)
          makeactive                        //将root指定的分区设置为活动分区
          chainloader +1                    //从指定位置加载Windows引导程序
        */

        要设置Grub引导多个系统，只要简单地把各个title组合在一起就行了
        /*
          default 0
          timeout 10  //选择时间为十秒,如果设置为0的话则自动依照第一个title的只是引导系统

          title Ubuntu 8.04.1, kernel 2.6.24-21generic
          root (hd0,4)  //从分区4启动Ubuntu 8.04
          kernel /boot/vmlinuz-2.6.24-21generic ro quiet splash locale=zh_CN
          initrd /boot/initrd.img-2.6.24-21generic
          quiet

          title Windows Vista/Longhorn (loader)
          root (hd0,2)  //或者从分区1启动Windows Vista
          savedefault
          makeactive
          chainloader +1
        */

        用户可以在Grub引导时手动输入命令来引导Grub的行为。在Grub启动时按下"C"键可进入Grub的命令行模式(官方手册www.gnu.org/software/grub/manual/){
          help   //显示帮助信息
          reboot //重新引导根分区
          root   //指定根分区
          kernel //指定内核所在位置
          find   //在所有可以安装的分区上寻找一个文件
          boot   //依照配置引导系统
        }
      }

      配置静态ip地址(不同的系统，文件所在的位置也不一样 Raspbian 系统的路径是"/etc/network/interfaces"、CentOS 的路径是"/etc/sysconfig/network/ifcfg-eth0"){
        网卡命名：eth0 eth1 eth2 lo
        ifconfig  //查看网卡信息,ip地址等网络参数
        ifconfig eth0 IP_ADDR netmask MASK   //一次性配置网卡，每次关机则重置
        vim /etc/sysconfig/network-scripts/ifcfg-eth0 //编辑网卡的配置文件，不同的系统可能路径不一样，此处为CentOS的路径，下次启动则不需要重新配置网卡
        DEVICE="eth0"          //网卡设备名
        BOOTPROTO="static"     //启动协议:static静态IP,dhcp动态IP,none
        HWADDR="00:0C:29:41:B6:9B"  //mac地址
        TYPE="Ethernet"        //连接类型：以太网
        UUID="10ec60b1-4342-4b51-a9a7-6f6b2c521178"  //UUID
        NM_CONTROLLED="no"     //是否接受NetworkManager的控制
        ONBOOT="yes"           //是否随系统开机启用，默认是no
        IPADDR=172.16.1.1      //静态ip地址
        NETMASK=255.255.255.0  //掩码
        GATEWAY=172.1.1.254    //网关
        DNS1=114.114.114.114   //DNS
        service network restart//重启网络服务，使配置文件重新被读取
        route -n               //查看路由表
        vim /etc/resolv.conf   //编辑dns的全局配置文件，nameserver（DNS） 114.114.114.114 115.115.115.115
      }

      配置桌面环境(注意与windows不同的是Linux不是一种基于图形环境的操作系统，而图形环境不过是一个普通的应用程序，用户在命令行中可以完成对电脑的一切操作，所以有配置桌面环境一说){
        运行应用程序:可以在系统菜单中选择，也可以在终端上直接输入名字，如果找不到应用程序的话，自己手动输入程序路径，然后去运行。(一般不存在这种情况，除非装程序的时候自己修改了安装目录)
          //这里特别指出在Ubuntu上的gedit编辑器，看上去和windows上的记事本很相似，但是它有拼写检查、语法高亮、文本加密、行号显示等功能，在编程的时候比较好用。

        浏览文件系统:同样可以在图形界面想windows一样进行选择，也可以在命令行中使用"ls" "cd" +"[路径]"等命令对文件进行操作，使用"Tab"自动补全，双击"Tab"查看可以补全的候选项。

        个性化设置:与Windows很相似，所以就不啰嗦了。都是鼠标右键。

        代理服务器设置:"系统"|"首选项"|"网络代理"

        X 窗口系统的基本组成(X Windows System 是Linux图形用户环境的基础){
          · X 服务器:X 服务器用于实际控制输入设备和位图式输出设备，X 服务器定义了给X 客户机使用这些设备的抽象接口而不是高级实体的编程接口。这意味着X 服务器能做到最大程度上的与平台无关。用户可以自由选择窗口管理器和widget 库来定制自己的桌面，而不需要改变窗口系统的底层配置。

          · X 客户端程序:需要向X 服务器请求服务的程序就是X 客户端程序。具体来说例如OpenOffice、gedit这些应用程序都是X 客户端程序，它们运行时需要把自己的"长相"描述给X 服务器，然后由X 服务器负责在显示器上绘制这些应用程序的界面。

          · 窗口管理器(Window Manager):主要负责控制应用程序窗口的各种行为，比如移动、缩放、最大化、最小化、在多个窗口间切换等。从本质上来说，窗口管理器是一种特殊的X 客户端程序，因为这些功能也都是通过向X 服务器发送指令实现的。Window Maker、FVWM、IceWM、Sawfish 等是目前比较常见的窗口管理器。

          · 显示管理器(Display Manager):提供了一个登陆界面，其任务就是验证用户的身份，让用户登录到系统。可以说，图形界面的一切(除了它自己)都是由这个显示管理器启动的,包括X 服务器。用户也可以选择关闭显示器管理器(可以在设置里面设置)，这样就必须通过命令行运行startx命令(或者使用 .login脚本)来启动X服务器。

          · Widget 库:Widget 定义了一套图形用户界面的编程接口。应用程序开发人员通过调用Widget 库来实现具体的用户界面，比如按钮、菜单、滚动条、文本框等。程序员不需要理解X 服务器的语言，Widget 库会把"画一个按钮"这句话翻译成X 服务器能够理解的表述方式。

          · 桌面环境:什么是桌面环境?以KDE 和Gnome 为代表的Linux 桌面环境是把各种与X 环境有关的东西(除了X 服务器)整合在一起的大杂烩，这些程序包括像gedit 这样的普通应用软件、窗口管理器、显示管理器和Widget 库。但无论桌面环境如何复杂，最后处理图形输出的仍然是X 服务器。
        }

        X 系统的启动过程(启动过程基本是由显示管理器完成的){
          启动X 服务器。
          提供一个友好的屏幕，等待验证用户的身份。
          执行用户的引导脚本，这个脚本用于建立用户的桌面环境。
          /*
            简单提一下"引导脚本"。桌面环境的引导脚本是一段用Linux 命令组成的脚本程序，叫做Xsession。Xsession 通过启动窗口管理器、任务栏，设定应用的默认值、安装标准键绑定等来启动整个桌面环境。通常桌面环境都有自己的启动脚本。
            Xsession 会一直运行，直到用户退出(或者说，当Xsession 运行结束后，用户就退出了)。窗口管理器是Xsession 启动的唯一前台程序(其它程序都在后台执行)，如果没有这个前台程序，那么用户会在登陆后又立即退出系统。
          */
        }

        X 应用程序的启动(X 窗口的服务器/客户机架构意味着一台主机上的X应用程序可以在另一台主机的屏幕上显示出来。X 服务器接受来自多个应用程序的请求，然后在本地显示。而这些应用程序可能正运行在网络中的另几台主机上){
          为了运行一个X 应用程序，必须指定在什么地方显示。环境变量DISPLAY 定义了这些内容(环境变量用于在系统运行时保存一些同系统和用户相关的信息。
          DISPLAY=servername:3.2  //这是一个DISPLAY 的典型设置，当应用程序启动时，它会查看这个环境变量。在这X 应用程序就会把自己的图形输出到主机servername 上的显示3和屏幕2上。
          /*
            "显示3和屏幕2"这个短语的意思是:如果一台主机只运行一个X 服务器，那么这个X 服务器就工作在端口6000，对应的显示号是0；如果再安装一个X 服务器程序，那么这个新的X 服务器会工作在端口6001，对应的显示号是1……以此类推。至于"屏幕2"，说的是在一台主机上连接有多台显示器的情况下，显示器也从0开始编号。第一台显示器为"屏幕0"，因此"屏幕2"就是这台主机所连接的第三台显示器。另外由于大部分主机只运行一个X 服务器，只运行一台显示器。所以可以简化为DISPLAY=servername:0.0V 。最为常见的是X 客户机(X 应用程序)向本地的X 服务器传递图形输出，X 服务器在本地的显示器上显示图形。此时就不需要再指定服务器名字了。环境变量退化为DISPLAY=:0.0 。由于屏幕号也可以省略(默认屏幕号为0)，因此在最简单的情况下，DISPLAY=:0  。
          */
        }

        X 服务器的配置(一般情况下默认配置就行了，如果用户的X 系统工作的不错就没有必要手动修改这些设置，使用图形化的配置工具能减少设置X 服务器的风险，但有时候不正确的设置(例如使用了错误的显卡驱动)可能会让使用者不得不在命令行下工作){
          X 服务器的配置文件路径"/etc/X11/xorg.conf" //修改X 服务器的配置文件需要root权限
          所有以"#"开头的都是注释行 //让用户更容易阅读和修改配置文件，应用程序会忽略配置文件中所有的注释行
          xorg.conf 的内容被分成几段，每一段以Section 开头，以EndSection结尾 //每一段负责完成一个特定的任务，以下给出各段的说明
          SeverFlags  //X 服务器的全局参数设置
          InputDevice //配置输入设备，比如鼠标、键盘、触摸板等
          Device      //配置显卡和驱动程序
          Monitor     //配置显示器的物理参数
          Screen      //把一台显示器和一块显卡联系起来
          Modules     //配置动态加载的扩展模块，这些模块通常用于图形加速、特效显示等
          ServerLayout//把输入设备和屏幕(Screen)联系起来
        }

        配置显卡(Device配置段用于描述一块特定的显卡){
          Section "Device"
            Identifier "Configured Video Device"  //用一个字符来标识这块显卡，这里显卡的名字就叫"Configured Video Device"
            Driver "fglrx"  //指定了用于这块显卡的驱动程序，这个驱动程序只有在相应的Section段被用到的时候才会加载
          EndSection
        }

        配置显示器(Monitor 配置段用于描述一台显示器){
          Section "Monitor"
            Identifier  "Configured Monitor"
            Option      "DPMS"       //"Option"用于开启特定属性，这里打开了"DPMS"(显示器电源管理)，让X 服务器在一段时间没有收到用户输入的时候关闭显示器电源
            HorizSync   30-65        //设定显示器的刷新频率
            VertRefresh 50-120       //设置显示器的刷新频率
            /*通常来说驱动程序都可以自动探测到HorizSync 和VertRefresh这两个参数，但是在Monitor 段致电该可以避免驱动程序使用显示器实际不支持的频率*/
          EndSection
        }

        联系显卡和显示器(完成显卡和显示器配置之后还需要通过"Screen"将二者联系起来){
          Section "Screen"
            Identifier   "Default Screen"          //同样是给这个屏幕取了一个名字
            Monitor      "Configured Monitor"      //指定使用的显示器
            Device       "Configured Video Device" //指定使用的显卡
            Defaultdepth 24                        //设置了X服务器默认使用的颜色深度，X 服务器需要依此判断使用怎样的分辨率
          EndSection
        }

        如果显示出了问题(由错误的显示器配置或者错误的驱动程序导致X 服务器无法正常工作，那么最简单的办法就是关闭所有的额外设置){
          Section "Device"
            Identifier    "Default Video Device"
          EndSection

          Section "Monitor"
            Identifier    "Configured Monitor"
          EndSection

          Section "Screen"
            Identifier    "Default Screen"
            Monitor       "Configured Monitor"
            Device        "Configured Video Device"
            Defaultdepth  24
          EndSection
          /*
            这样已有的显卡驱动就会被X 服务器忽略，以最"原始"的方式使用显示器。卸载出问题的驱动程序，并逐步恢复配置，重新启动X 服务器，直到显示器正常工作。
          */
        }
      }
    }
}

3.系统管理(){
  class Shell(Shell 基本命令){
    Shell 简介(由于Shell是在tty终端中运行的，所以一下tty终端内的命令行操作同样适用于Shell 内容，于此不再重复){
      命令行和Shell。这两个概念往往是令人困惑的。在很多不正式的场合，这两个名词代表着相同的概念，即命令解释器。然而从严格意义上讲，命令行指的是供用户输入命令的界面，其本身只是接受输入，然后把命令传递给命令解释器,而后者就是Shell。从本质上来讲，Shell 只是一个程序，它在用户和操作系统之间提供了一个面向命令行的可交互接口。用户在命令行中输入命令，运行在后台的Shell 把命令转换成指令代码发送给操作系统。Shell 提供了很多高级特性，使得用户和操作系统之间的交互变得简便和高效。目前，在Linux 环境下有几种不同类型的Shell ,常用的有Bourne Again Shell (BASH)、TCSH Shell、Z-Shell 等。不同的Shell 提供不尽相同的语法和特性，用户可以使用任意一种Shell 。在Linux 上,BASH Shell 是默认安装和使用的Shell 。
    }

    印刷约定(){
      Linux 命令行界面有一个输入行，用于输入命令。在BASH 中，命令行通过一个美元符号"$"作为提示符，表示用户可以输入命令了。下面就是一个Shell 提示符，表示命令行的开始。
      $
      如果正在以root的身份执行命令，那么Shell 提示符将变成"#"，如下所示。
      #
      /*
        在BASH 的美元提示符之前，一般还会有一段信息，包括用户名、主机名和当前目录(命令行中输入的# 后面的内容会被当作注释)，如下所示。
        lweis@lweis-laptop:/home$     ##用户名lweis，主机名lweis-laptop，当前目录home
      */
      为了印刷的紧凑和突出特点，一般省略"$"前面的那段信息。而对系统的输出过长的话也一般只将重点标出，其它的用"……"代替。一般需要给出命令语法的地方选部分使用"[]"表示，参数部分则用"斜体"表示。最后在所有需要用到root 权限的地方，一般都用"sudo"工具，因为使用"sudo"工具临时提升用户权限是一个好的习惯，在某些不适合使用"sudo"的地方一般另加说明。
    }

    class tty(Teletypewriter 终端/电传式打字机)(其实所有的用户指令可以在"/usr/bin/" 目录下找到){
      linux可同时开启多个不同用户名的终端//  linux是多用户多任务操作系统，Windows是单用户多任务操作系统
      Command [OPTIONS] Argument//命令语法
      clean           //清屏
      tty             //查看当前终端路径
      who             //用户及版本信息查看。可以查看有哪些人在登陆，以及他们都在哪个控制台上。"whoami"可以查询目前自己是以什么身份登陆到系统
      uname           //用于显示当前系统的版本信息，"-a"选项则会给出当前操作系统所有有用的信息，"-r"则只显示内核版本信息
      man             //manual 寻求命令帮助。实际上"man"命令在显示手册页时实际调用的是"less"程序。man 手册的组织路径在"/usr/share/man"
        /*
          man1 普通命令和应用程序
          man2 系统调用
          man3 库调用，主要是libc()函数的使用文档
          man4 设备驱动和网络协议
          man5 文件的详细格式信息
          man6 游戏
          man7 文档使用说明
          man8 系统管理命令
          man9 内核源代码或模块的技术指标
        */
      whatis          //有时候man 手册中的长篇大论太啰嗦，"whatis"从某个程序的使用手册页中抽出一行简单的介绍性文字供人们查看，原理基本同"locate"一致
      apropos         //是"whatis"的反命令，即通过查找使用手册中的关键词来查找想要的命令
      cutl+alt+F1-F7  //切换终端
      Tab             //自动补全，双击则查看补全候选项
      ctrl+a          //光标移到行首
        ctrl+e          //光标移到行尾
        ctrl+c          //终端当前命令的执行
        ctrl+d          //logout，登出用户
      "*"、"?"、"[]"  //通配符，分别代表用于匹配文件名中任意长度的字符串、只匹配一个字符、匹配所有出现在方括号中的字符(也可以用短线"-"来指定一个字符集的范围，包括数字范围和ASCII码中字母的范围)
      [NAME]          //直接输入程序名，就可以从终端运行程序，按下Enter 后当前终端会被挂起，直到运行的程序关闭，如果要让程序后台运行则需要在命令后加上"&"，而相应的当前终端则不会被挂起，可以继续工作
      whereis         //查找特定程序，该命令主要查找程序文件，并提供这个文件的二进制可执行文件、源代码文件和使用手册页存放的位置，可以用"-b"让"whereis"只查找这个程序的二进制可执行文件。当文件无法找到时将返回一个空字符串
      startx，init 5  //从命令行进入图形化界面
      runlevel        //查看运行级别，决定系统启动后直接进入什么模式，当然也可以在设置里面修改。配置文件路径 /etc/inittab
        {
          Default runlevel. The runlevels used are:
         #   0 - halt (Do NOT set initdefault to this) //关机
         #   1 - Single user mode                     //单用户模式（改root密码）
         #   2 - Multiuser, without NFS (The same as 3, if you do not have networking) //(多用户模式，没有网络功能)
         #   3 - Full multiuser mode                  //（全功能的多用户模式）
         #   4 - unused                               //保留，未使用
         #   5 - X11                                  //图形化,X Window System，也可以用startx来实现
         #   6 - reboot (Do NOT set initdefault to this) //重启，也可以shutdown -r now/reboot
        }
      init ?(0-6)  //临时到切换运行级别?，需要在root权限下才能使用

      目录(路径){
        pwd  //显示工作目录，因为不是所有的Linux系统中的Shell 都会显示当前工作路径，Freebsd等操作系统中BASH则不自动显示当前目录
        cd   //change directory进入所选目录
        #~   //家目录。用户登录后，默认处于自己的家目录
        dir  //在Linux上dir 除了比ls 的功能更少，其他都是一样的，"cdir"则等于"ls -l"
        cat  //用于查看文件内容，通常是文本文件，后面跟参数，例如"-n"则显示行号，直接输入cat 的时候cat 会停在那里，等待着从标准输入(键盘)获取数据，"Ctrl+D"提供给"cat"一个文件结束符
        more //分页显示内容，"空格"向下翻动一页，"回车"向下滚动一行，"Q"退出
        head //阅读文档开头
        tail //阅读文档结尾,tail 和head 的输出都是默认包括了文件名的
        less //更好的文本阅读工具，其与"more"非常相似，但其功能更为强大，改进和添加了许多细节，这让less 看起来更像是一个文本编辑器——只是去掉了文本编辑功能
          /*
            使用光标键在文本文件中前后左右滚屏(也支持hjkl控制)
            用行号或百分比作为书签浏览文件
            实现复杂的检索、高亮显示等操作
            兼容常用的字处理程序(Emacs、Vim)的键盘操作
            阅读到文件结束时less命令不会退出
            屏幕底部的信息提示更容易控制使用，而且提供了更多信息
            "空格"向下翻页
            "B"向上翻页
            "/"查找字符串并把第一个搜索目标高亮显示。要继续查找相同的内容，只需要再次输入正斜杠"/"，并按下"回车"就行了
            "-M"显示更多的文件信息
            "Q"退出
          */
        grep //查找文件内容，如果使用"more"命令一行一行去找的话，无疑是很费时费力的。当文件特别大的时候，这样的做法就变得几乎不可行了。
          /*
            用法"$grep [OPTIONS] PATTERN [FILE...]"
            例如"$grep 'Red Hat' day weather"搜索day 和 weather 文件中的"Red Hat"关键词
            严格地说，grep 通过"基础正则表达式(basic regular expression)"进行搜索。和"grep"相关的一个工具是"egrep"，除了使用"扩展的正则表达式(extended regular expression)"，egrep 和 grep 完全一样
            "扩展正则表达式"能够提供比"基础正则表达式"更完整地表达规范
          */
        ls //查看目录的文件
          /*
            用法"$ls [optnios] [PATH]"
            默认情况下目录显示为蓝色，普通文件显示为黑色，可执行文件显示为草绿色，淡蓝色则表示这个文件是一个链接文件(相当于Windows 下的链接文件)
            options:
              短选项    //同时指定多个短选项时候只需要使用一个短线就行了
                -a     //all,显示目录下的所有文件，包含隐藏文件
                       //隐藏文件即以"."开头的文件
                -l     //long fomat,文件的向详细属性，例如"drwxr-xr-x 2 root root 4096 2016-02-01 08:15 conf.avail"，分别对应文件权限标志，文件链接个数，文件所有者用户名，该用户所在的用户组组名，文件的大小，最后一次修改的日期和具体时间，文件名
                  /*
                    文件类型(第一个字符就是文件类型)
                      - 普通文件
                      d 目录
                      c 字符设备文件  //指能从中读取字符序列的设备，比如磁带和串行线路
                      b 块设备文件    //指用来储存数据并对其各部分内容提供同等访问权的设备，即随机读写。拥有设备文件不代表拥有设备，只代表系统有处理这种设备的"潜能"。设备文件可用"mknod"创建
                      s 本地域套接口　//详见《进程间通讯》，普通用户用不到，但是程序员用得到
                      p 有名管道      //同上
                      l 符号链接      //类似于Windows中的快捷方式，用户可以通过别名去访问另一个文件
                  */
                -d     //只查看目录本身的属性
                -F     //在每个目录后加上"/",在可执行文件后加"*"，在链接后加"@"，这个选项在某些无法显示颜色的终端上有用

              长选项
                --all  //同 -a
                --help //查看帮助文档
          */
        find //能够迅速在指定范围内查找到文件
          /*
            用法"$find [OPTIONS] [path...] [expression]"
            例如"$find /usr/bin/ -name zip -print"希望在"/usr/bin/"目录中查找"zip"命令，并且输出到显示器上
            "find"命令在这还有很多选项比如说指定文件类型(后缀名)的"-type"、"-atime n"、"mtime -n"
            "-type"可供使用的参数"b块设备文件"、"c字符设备文件"、"d目录文件"、"f普通文件"、"p命名管道"、"l符号链接"
            "-atime n"用于查找最后一次修改在n 天前的文件，+n 表示大于n，-n 表示小于n天。
            "-mtime n"类似的这个用于查找当前目录中最近一天内修改过的文件
            注意"find"命令会打印出文件的绝对路径
            如果在输出结果中出现了"Permission denied"则说明搜索时跳过了普通用户没有操作权限的文件夹
          */
        ln //建立链接
          /*
            符号链接(软链接)
              需要用带"-s"参数的"ln"命令来创建
              用法"$ln -s [TARGET] [LINK_NAME]" //给目标文件TARGET 起了一个别名LINK_NAME
              从此访问LINK_NAME 就相当于访问TARGET，在属性中也可以看到LINK_NAME 文件被指向TARGET
              因为LINK_NAME只是一个别名，所以删除LINK_NAME 并不会影响TARGET ，但如果将TARGET 删除了，那么保留在那里的LINK_NAME 也没有任何意义了
              符号链接还可以用于目录

            硬链接
              使用不带选项的"ln"命令建立硬链接
              查看文件属性可以发现，链接的文件和源文件是两个完全独立的文件，只是被联系在一起了而已
              这两个文件拥有相同的内容，对其中一个文件的修改会反映到另一个文件中
          */
        locate //更快速的定位文件，没有这个命令的话就去安装mlocate 包
          /*
            用法"$locate [NAME.TYPE]"
            搜索结果几乎是在一瞬间就出现了，事实上"locate"命令并没有进入子目录搜索，这有些类似于Google 的桌面搜索(或者Windows 的快速搜索)，通过检索文件名数据库来确定文件的位置
            "locate"命令会自动建立整个数据库而不需要用户插手，如果希望立刻生成该数据库文件的最新版本，那么可以使用"updatedb"命令，当然运行的时候需要有root 权限，整个数据库更新大概耗时1分钟左右
          */
        绝对路径(以 / 开头的路径)  //直接$cd / 则表示进入根目录，$cd 不带任何参数则进入用户主目录
        相对路径(相对于当前目录的路径){
          #.  当前目录
            #.. 上一级目录
            #~  家目录
        }
      }

      输入输出重定向和管道(重定向和管道是Shell 的高级特性，允许用户人为地改变程序获取输入和产生输出的位置){
        stout 程序在默认情况下输出的地方，称为标准输出  //通常来说标准输出指的是显示器
          > 输出重定向 //举例"$ls > ~/ls_out"则"ls"命令的输出结果不会显示在显示器上而是输出在ls_out文件中
          >> 输出重定向  //">"并不会在原来的文件属性上填上版本信息，而">>"则会添加上版本信息

        stdin 程序默认接受输入的地方称为标准输入 //通常来说总是指向键盘
          < 输入重定向 //可以让一个程序从文件中获取输入
          事实上大部分命令都能以参数形式在命令行上指定输入档的文件名，如"$cat < FILE"可以用"$cat FILE"替代
          <<  立即文档(here document)，明确告诉Shell 从键盘接受输入，并传递给程序
            /*
              $cat << EOF //指定结束符号
              >Hello      //输入文字
              >Bye
              >EOF        //结束
              Hello       //多行"打印"
              Bye
            */

        管道 将一个命令的输出连接到另一个命令的输入
          | 管道
            /*
              $ls /days/ |grep ay //列出days中的所有文件，然后用"grep"查找关键词"ay"，并将结果显示出来
              days
              hard_days
              mplayer
              my_days
            */
            在一个命令行中可以使用多个管道，从而构造出复杂的Shell 命令。合理使用管道是提高工作效率。
      }
    }

    class FileSystem{
    文件系统：明确存储设备或者分区的数据结构，Linux 目录结构和Windows 有很大不同。首先就是Linux 没有"盘符"的概念。已建立文件系统的硬盘分区被挂载到某个目录下，用户通过操作目录来实现磁盘读写。Linux使用"/"而Windows使用\
    常见文件系统：
        windows :NTFS,Fat32(single file couldnt more than 4GB)
        Linux   :ext3/4,XFS
        CD-ROM  :iso9660

        FHS(Filesystem Hierarchy Standard 文件系统目录标准){
         1、定义根目录下存放的文件
         2、/usr /var目录下存放内容文件
         各种目录：
                主目录(不带任何参数"$cd"直接进入)//主目录下存放着一些配置文件和用户的私人文件。用户主目录默认对其他用户关闭访问权限，这意味着guest(来宾账户)不能看到"户主"的主目录下的任何东西
         bin    构建最小系统所需要的命令文件(二进制/系统基本命令)
         boot   系统引导文件(启动系统,常设为独立分区)
         dev    设备文件及其配置(块设备&字符设备)
                  块设备：随机读写数据(U盘 CDrom 硬盘)(b开头)
                  字符设备：顺序读写数据(终端流制控制器(DOS))(c开头)
                $相关用法：echo #text# > /dev/tty#number# 发送信息text到tty
              /dev/zero 零字符设备
                $相关用法：dd if=输入路径 of=输出路径 bs=大小 count=读取次数 //可用于扩展swap分区
              /dev/null 黑洞设备
                $相关用法：用于回首垃圾资源
         etc    存放着系统以及绝大部分应用软件的配置文件(与Windows 不同Linux 使用纯文本文件来配置软件，修改配置文件可以很方便的对软件进行定制)
                $相关用法：inittab fstab //$cat /etc/fstab 查看这个文件可以发现，其中定义了各个硬盘分区所挂载到的目录路径。
         lib    模块文件/C编译器的库(内核模块/lib/modules/2.6.32-.....64)
                $相关用法：uname -r 查看内核版本
         media  可移动介质的挂载点()
         mnt    临时挂载点()
         opt    附加软件库(安装路径)(已废弃)
         sbin   系统命令文件(系统管理相关的二进制文件)
                $相关用法：mkfs 格式化
         srv    服务数据储存()
         tmp    临时文件区()
         usr    拓展文件区()
                重要路径：/usr/local //软件源码编译安装的附加软件库
                  /usr/bin   实现系统 扩展功能 的可执行文件
                  /usr/share 结构独立的数据/文件储存器
         var    可变数据()
                  /var/log      系统日志文件区
                  /var/www/html web服务的网页根目录(网页引导开启)
                  $相关用法：yum httpd -> /var/www/html/*.html
                    开发linux前端网页                   */
                  /var/ftp    ftp的根目录
         root     root家目录()
         home     用户家目录(如果是有多个用户的话，在该目录下会有多个以用户名命名的文件夹)
         proc     内核的伪文件系统() 可查看的内核参数的映射文件
         sys      内核伪文件系统，系统硬件参数的映射文件系统(实际地址在内存里面，文件本身不占硬盘空间)
        }

        private class FileName(){
            文件命名规则：255字符以内，不能用/命名，严格区分大小写
        }

        private class FileType(){
            命令：简单小程序
            $相关用法：man bash //查看命令列表
            $相关用法：type #文件名#//查看文件类型
            $相关用法：多个指令执行，需用分号进行分隔
                      一行不够写，用\续行
            $相关用法：CMD --help
                      man CMD
                      info CMD
                      whatis CMD //以上为查看命令的功能
                      which CMD //查看命令的绝对路径
        }

        文件查看(在之前有写过){
          cat(文本文件)/vim/more(分屏浏览)/less(分屏浏览不退出) #PATH#
          空格 //下翻
          b //上翻
          q //退出
          ll [FILE] //查看大小
          }
            目录(文件筛选)：
              通配符:用来匹配文件名的符号
                  * :(任意数量的任意字符)(asb* 即以asb开头的所有文件/目录)//(-d 不显示目录)
                  ? :(单个数量的任意字符)
                 [] :(字符集)([0-9][aZ])
            $相关CMD：tree
        }

        文件创建(){
            创建文件：
              $相关用法：vim #FILE#
              $相关用法：touch #FILE#  //"touch"建立的文件是空文件，当某些应用程序因为缺少文件而无法启动，而缺少的文件不是那么重要时可以用这个命令建立一个空文件"骗过"这个程序。"touch"还可以用于文件备份
            创建目录：
              $相关用法：mkdir #MENU#(创建一级目录)(创建多个同级目录只需要在目录之间用"空格"分开就好)
              $相关用法：mkdir -p #MENU#(自动创建多级目录)
        }

        文件拷贝(){
              $相关用法：cp #FILE# #FILE# //复制
              $相关用法：-r/R 递归       用于整个目录的拷贝
                        -a 归档(备份)   拷贝时保留所有属性(如不改变时间戳等MSG)(用于备份文件)
                        -f 强制         不交互
                        -v 显示过程信息
                        -b 在拷贝文件之前，首先在目标目录的同名文件的文件名后加一个"~"，从而避免文件被覆盖
              $相关用法：cp #FILE# #FILE# #FILE# ...    #PATH#//批量拷贝
              $相关用法：cp #FILE# #FILE#(拷贝并重命名) //   ./*  当前目录所有内容    */
        }

        文件移动或者重命名(){//剪切
              $相关用法：mv 与cp相近
                        mv DIR DIR
                        mv FILE DIR
                        mv FILE FILE //文件重命名
                        -i 交互(尤其是可能不小心覆盖源文件的时候)
                        -b 在移动文件之前，首先在目标目录的同名文件的文件名后加一个"~"，从而避免文件被覆盖
        }

        文件删除(){
              $相关用法：rm #FILE# //删除 (-f 强制删除)
                        rmdir     //清除空目录，或者删除目录
                        rm -r #DIR# //删除目录 (如rm -rf /*)
        }
        alias 定义&查看别名 //alias cls='clear'
        unalias 取消别名    //unalias cls;

        创建文件系统(){
          /* Linux分区(制作文件系统)
              1.分区
              2.制作文件系统
              3.挂载
              4.写入/etc/fstab (File System Table)
              */
         -T 显示文件系统类型
         -h 格式人类可读化(-Th 建立在1024上 -TH 建立在1000上)
         -s 汇总
            $相关用法：fdisk -l /dev/sda1 //查看硬盘分区表
            $相关用法：du -sh #DIR# //查看目录大小
            $相关用法：file #FILE#  //查看文件类型

        分区(){
            $相关用法：fdisk -cu /dev/sta?
              p #print  //显示分区表（查看是否还有空间分区）
              n #new    //创建新的分区(主分区和扩展分区)
              w #write  //保存
              d #delete //删除
              t         //修改分区系统id(类型)
              l         //列出所有已知的系统类型
            /*
              主分区？/拓展分区？
                创建拓展分区，在其中创建逻辑分区
            */
            $相关用法：partx -a 重读分区表（两次）(新硬盘分区时不需要重读分区表)

            格式化(){
              $相关用法：mkfs -t #FileSystemTYPE# #DIR:DEV#
            }
            挂载(){
              $相关用法：mkdir /mnt/disk{5,6}//创建挂载点
              $相关用法：mount -t #FileSystemTYPE# #DIR:DEV# #DIR:mount_point#//挂载(直接输入可以查看相关属性)
                ↘operation:
                -t
                -a            //测试文件挂载时候正常
                -o +[#default //选择挂载模式（default为所有设置均为默认）
                rw        //读写
                suid      //set-uid 特殊权限
                dev       //是否可以被解释（nodev不能被解释，即不能挂载块设备）
                exec      //文件是否能执行(noexec 不能被自动执行，防止恶意软件自动运行)
                auto      //能否被mount -a 挂载
                nouser    //不允许普通用户管理文件系统
                async     //sync 同步，async 异步写入（修改的文件不会马上改到硬盘里面）
                ro        //只读
                loop      //挂载本地iso（redhat7及其对应的衍生版本以下才要）
                remount   //原子重新挂载（速度非常快，业务不中断）
                属性叠加用逗号隔开(mount -t ext4 -o remount,sync,* ## ##)
                $相关用法：umount #DIR# 卸载
            }(以上对应反操作在前面加no)

            写入(/etc/fstab){
              文件内容显示格式：  挂载源      挂载点     文件系统类型       mount options       是否备份    是否检查
              挂载方法：
                UUID=
                  $相关用法：blkid+地址 块设备查看UUID(系统重要的分区都会用UUID挂载)
                LABEL=
              $相关用法：
            }
          }
      }

      和团队共享文件(涉及到文件和目录的权限){
        假设团队成员的用户名分别为lucy、lweis、mike、peter，他们都属于workgroup 这个用户组
        $sudo groupadd workgroup  //新建一个名为workgroup 的用户组
        $sudo useradd -G workgroup lucy //新建用户，并归入workgroup 组
        $sudo passwd lucy //为用户lucy 设置登录密码
        ...
        $cd /home //切换到/home 目录
        $sudo mkdir work  //现在任何人都可以访问这个新建的目录，而只有root 用户才拥有该目录的写权限
        $sudo chgrp workgroup work/ //将work 目录的所有权交给workgroup 组
        $sudo chmod g+rwx work/ //增加workgroup 组对work 目录的读、写、执行权限
        $sudo chmod o-rwx work/ //撤销其他用户对work 目录的读、写、执行权限
        $sudo chown lweis work/ //将work 目录的所有者改为lweis 用户(在输入这行命令之前work 目录的所有者还是root 用户)
        //现在所有属于这个组的成员都可以访问并修改这个目录的内容了，而其他未授权的用户(除了root)则无法看到其中的内容。而组成员新建的文件可以被别的 成员修改或者删除

        Linux 为三种人准备了权限——文件所有者(属主)、文件属组用户、其他人。但root 用户其实是不应该被算在"其他人"中。因为root 用户拥有控制一台计算机的完整权限。文件所有者通常是文件的创作者，但这也不是一定的。可以途中改变一个文件的属主用户，这必须直接由root 用户来实施。当然也可以把文件交给一个组，这个组就是文件的属组。

        一般涉及的权限有三种:读取"r"、写入"w"、和执行"x"。要让一个文件可执行，必须设置其执行权限。可执行文件有两类，一类是可以直接由CPU执行的二进制代码，另一类是Shell脚本程序。对于目录而言，所谓的执行权限实际控制了用户能否进入该目录；而读取权限则负责确定能否列出该目录中的内容；写入权限控制着在目录中创建、删除和重命名文件(能否删除和重命名一个文件是由其父目录的权限设置所控制的),因此执行权限是最基本的权限。

        chown(改变文件所有权){
          用法"$sudo chown [OPTIONS]...[OWNER] [:[GROUP]] FILE..." //FILE的属主改为"OWNER"，属组改为"[GROUP]"(前面的冒号不能省略)，支持"-r"递归
          //Linux单独提供了另一个命令"chgrp"用于设置文件属组，用法"$sudo chgrp [GROUP] FILE..."实际上使用该命令与否取决于用户的个人习惯
        }

        chmod(改变文件权限){
          "chmod"使用"用户组+/-权限"的表述方式来增加/删除相应的权限。具体来说，用户组包括了文件属主"u"、文件属组"g"、其他人"o"和所有人"a"，而权限则包括了读取"r"、写入"w"、和执行"x"权限。
          权限之间用","隔开，可以通过"="直接设置文件权限，并且"="传递性可以从一种用户传给另外一种用户，例如"$sudo chmod ug=rw,o=r days"，表示赋予属主和属组读取和写入权限，而赋予其他用户读取权限。
        }

        文件权限的八进制表示(便于输入，要求记住八进制加法){
          每一组权限"rwx"在计算机中实际上占用了3位，每一位都有两种情况，"1"对应开启该权限，"0"对应关闭(-)该权限。例如"011"对应的权限就是-wx，而011(2)=3。这样一来完整的9位权限就可以用3个八进制数表示了，例如最常用的"711"就对应"rwx--x--x"这样除了属主和root 其他的都只有执行权限了。
        }
      }
  }

    class vi(vi编辑器的基本用法){
      普通模式：
          a   # 进入插入模式，光标向右移动一个字符
          i   # 进入插入模式，光标位置不变
          :   #进入末行模式
      #esc返回上一级模式，esc esc直接返回普通模式
      插入模式
      末行模式：
          w   #write，保存
          q   #quit，退出
          !   #强制
          wq  #保存并退出
          q!  #不保存退出
          r   #read
      .*file    //隐藏文件 ls -a 查看
      PXE       //无盘工作站网启选项
      PE        //U盘引导选项

        vi编辑器//全屏编辑器
                //其他编辑器：gedit nano vim~vi(vim是vi的升级版，兼容Unix和linux，Windows和MAC也有)
          三个模式：
            普通模式：光标移动，内容操作(复制，剪切，粘贴)，其它模式的入口（默认模式）
                1.光标移动 方向键移动(hjkl对应左下上右)
                           w(跳转到下一词汇首，大写时按照空格跳转，不再识别符号)
                           b(跳转到上一词汇首，大写时按照空格跳转，不再识别符号)
                           e(跳转到下一词汇尾，大写时候按空格跳转，不再识别符号)
                           gg(光标移动到首行)
                           G(光标移动到末行)
                           ?gg(移动到第?行)
                           ?G(同上)
                           ^(S+6 脱字符 跳到行首)
                           $(S+4       跳到行尾)
                           //前面加数字可以移动指定次数(按照顺序按)

                2.内容操作  d(delete剪切) //3dl 向右剪切三个字符 3dw 剪切当前单词和后面的两个单词 dd 剪切当前行 一直按住d则全部剪切 也可以加脱字符
                           y(yanked拷贝) //同上 5yl 向右拷贝5个字符 3yy 拷贝当前行和下面的两行
                           p(粘贴)//同上 p粘贴到光标后 P粘贴到光标前插入
                           u(undo撤销)
                           Ctrl+r(反撤销)
                3.插入模式：a(光标在当前位置的下一个位置进入插入模式)
                           A(光标在当前位置的行末位置进入插入模式)
                           i(光标在当前位置的上一个位置进入插入模式)
                           I(光标在当前位置的行首位置进入插入模式)
                           o(光标向下另起一行进入插入模式)
                           O(光标向上另起一行进入插入模式)
                4.替换模式：r(替换当前光标一次)
                           R(进入替换模式)
                5.可视模式：v(选择光标当前位置的字符到结束位置的字符)
                           V(进入行可视模式)
                           Ctrl+v(进入块可视模式)
                6.窗口模式：Ctrl+w,s(水平分隔)
                           Ctrl+w,c(关闭当前窗口)
            末行模式：      :(进入末行模式)//对文件进行操作
                           set number     //设置行号                set nu
                           set ignorecase //忽略大小写，搜索时候用   set ic
                           set autoindent //自动缩进                set ai
                           nohighlight    //取消高亮                nohl
                           /STRIGN        //搜索STRING并且高亮，n/N搜索结果跳转
                           s/STRING/??/g  //搜索当前行的所有(g)的STRING并替换为??
                           %s/STRING/??/gc //搜索文本内的所有(g)的STRING并替换为??，并进行交互(/c可以实现选择性替换)
                           r #PATH-FILE#  //将文件内容导入光标位置
                           w #PATH-FILE#  //另存为
                           !              //强制
                           n,m #CMD#       //从n行到m行执行CMD操作(m若为%d则表示从n到最后)
            vim全局设置：   vim ~/.vimrc
    }
  class Packages(软件包管理){
    顾名思义，软件包是将应用程序、配置文件和管理数据打包的产物。特定的软件包管理系统可以方便地安装和写在软件包。如今，所有的Linux 发行版都才用了某种形式的软件包系统，这使得在Linux 上安装软件变得同Windows 下一样方便。常用的有两种，这取决于所使用的发行版。SUSE、RedHat、Fedora 等发行版本使用RPM ，而Debian 和Ubuntu 使用".deb"格式的软件包。

    安装
      对于Debian 和Ubuntu 及其它衍生版本的用户，安装方式为
        $sudo dpkg [OPTIONS] [.deb] //安装的话选项为"-i"(--install)，"-l"可以列出当前系统上已经安装的软件包，一般要查找已安装的软件的话配合管道命令使用"$dpkg -l | grep [NAME]",当然对于系统管理员而言，常常需要知道所安装的软件究竟向系统中复制了哪些文件，为此"dpkg"提供了"--search"选项(简写为"-S")，提供更详细的信息
        $sudo apt-get install [.deb]

      对于openSUSE、RedHat 等其他使用RPM包的用户
        $su   //提升权限至root
        #rpm [OPTIONS] [.rpm] //一般将[OPTIONS]设为"-ivh"(分别是安装、显示rpm 正在执行的工作，显示进度)。也可以用"-q"选项查看已安装的软件包，用户需要指定软件包的名字而不是安装文件的名字。"-a"选项列出安装的所有软件包，同样可以结合管道和"grep"使用
        #yum [.rpm] //yum只能用于RPM包

      //如果不是迫不得已永远不要使用"--force-"选项进行强制安装

     卸载
      一般在选项中实现，具体选项还是自行查看命令说明 //有时候因为软件包依赖的缘故，卸载某个软件包可能导致其他软件不能用的情况。例如xorg-X11-devel被多个软件包所依赖，所以RPM会谨慎地拒绝了这一卸载请求。如果用户执意要卸载的话可使用"-nodeps"选项。另外一个十分有用的选项是"--test"，它要求RPM 模拟写在软件的全过程，但不真的执行删除操作。再加上"-vv"选项则要求RPM输出完整的调试信息。
      $sudo dpkg -r [NAME]
      $sudo rpm -e [NAME]

     升级
      $sudo rpm -Uvh [.rpm]

     高级软件包工具APT、yum等
      APT(Advanced Package Tool)即高级软件包工具。这是现今最成熟的软件包管理系统。它可以自动检测软件依赖问题，下载和安装所有文件。甚至只需要一条命令就可以更新整个系统上所有的软件包。当然现在各Linux 发行版也开发了图形化高级软件包工具界面，鉴于其操作非常简单，所以在此不做说明

        "apt-get" //执行和软件包安装有关的所有操作
          系统第一次启动的时候就需要运行"apt-get update"更新当前"apt-get"缓存中的软件包信息，此后就可以用"apt-get install"安装软件包了。事实上，最好在每次安装和更新软件之前都更新一下，以保证获得的软件包是最新的。
            apt-get install //下载并且安装软件包
            apt-get upgrade //下载并安装在本系统上已有软件包的最新版本
            apt-get remove  //卸载特定的软件包
            apt-get source  //下载特定的软件源代码
            apt-get clean   //删除所有已下载的包文件
            apt-get -h      //列出"apt-get"的完整用法

        "apt-cache" //查找软件包的相关信息
          同"rpm"和"dpkg"一样，使用"apt-get"安装和卸载软件包时必须提供软件包的名字。"apt-get"并不能理解拼写错误或任何与其缓存中软件包名不相符的写法。因此提供正确的软件包名显得尤为重要，于是APT 提供了工具"apt-cache"来辅助操作。
            apt-cache search [NAME] //搜索带"NAME"字样的软件包，并按照字母顺序搜寻列出一切包含该字样的包
            apt-cache depends [NAME]//列出特定软件包的依赖关系

      配置apt-get(/etc/apt/sources.list){
        deb/deb-src //表示软件包的类型。Debian 类型的软件包使用"deb"或"deb-src"如果是RPM 的软件包，则应该使用"rpm"或"rpm-src"其中"src"(source)表示源代码
        URL //表示指向CD-ROM、HTTP或者FTP服务器的地址，从哪可以获得所需的软件包
        hardy等 //表示软件包的发行版本和分类，用于帮助"apt-get"遍历软件库
        # //注释行，如果想要暂时禁止一个安装源，可以考虑在行首加个"#"，而不是直接删除这一行，万一以后要用到
      }

      编译
        为什么要从源代码编译软件?尽管看起来各种软件包管理工具已经非常完美的解决了Linux 下的软件安装问题，但有些时候仍然不得不求助于最原始的方法，从源代码编译，这主要基于以下几个原因：

          一些软件开发商出于各种各样的原因，并没有提供二进制的软件包；或者只为了某个特定的发行版本提供了这样的软件包。这样，从源代码编译安装软件就成了唯一的方法。

          鉴于Linux 及其下软件的开放性，一些企业和个人出于特殊要求的考虑，需要修改某些软件的源代码。这些经过修改的软件必须重新编译。

          从源代码编译软件通常能让编译者获得更多的控制，例如软件的安装位置，开启和禁用某些功能等。有些人认为这非常重要，尽管这样作出的选择可能并不是高效和安全的。

         这里以Mplayer 为例
          从官网"www.mplayerhq.hu"下载最新版的源码，这里以Mplayer 1.0rc2的软件源码和Bule Skin皮肤为例子
          $tar jxvf Mplayer-1.0rc2.tar.bz2  //解压缩Mplayer-1.0.0rc2
          $tar jxvf Blue-1.7.tar.bz2        //解压缩皮肤
          $ls -F                            //解压后产看目录，得到Mplayer-1.0rc2 和Blue 两个目录
          $./configure --prefix=/usr/local/games/foobillard  //安装在指定位置，如果不使用"prefix"则安装在默认位置
          $cat README                       //查看安装手册(去解压文件目录)，在这找安装图形界面需要的选项
          $./configure --enable-gui         //Mplayer 提供了"--enable-gui"选项配置启用图形界面
          $make                             //"configure"检查完当前系统是否符合编译条件(Linux 下默认编译器为gcc )，如果"configure"脚本没有出错的话则会自动输出提示，告诉用户接下来要做什么。"make"是一种高级编译工具，它可以根据makefile 文件中的规则调用适合的编译器编译源代码。因为大型软件总是由大量模块组合在一起，其中源代码文件的联系错综复杂，因此不可能逐一手动编译这些文件。使用"make"工具可以按照预先设定的步骤(这通常是由"configure"脚本完成的)自动执行所有的一切。最后编译的时间取决于机器性能

      安装到硬盘
        $sudo make install  //编译完成之后，安装软件。至此Mplayer 主程序安装完毕，接下来安装皮肤
        $cd ... //进入皮肤目录所在的目录
        $sudo cp -r Blue/ /usr/local/share/mplayer/skins/default  //在README 有介绍皮肤文件的放置路径

      编译出错怎么办
        /*
          New_Face falied.Maybe the font path is wrong
          Please supply the text font file (~/.mplayer/subfont.ttf).
          subtitle font: load_sub_face failed
        */
        从错误信息来看应该是找不到字体文件，此时再去README 文件看看，原来是当初安装的时候漏了这一步，所以接下来只需要从系统中选择一个".ttf"字体文件，并且复制为"~/.mplayer/subfont.ttf"放到相应文件夹就行了
  }

  磁盘管理(包括Linux 文件系统的概念以及使用、硬盘分区以及格式化、使用外部设备、文档归档以及备份){
    Linux 文件系统(简单来说文件系统是对物理空间的组织方式){
      ext2fs 和ext3fs 文件系统
        过去很长一段时间，ext2fs(Second Extended File System)是Linux 上主流的文件系统，随着ext3fs 的出现，ext2fs 逐渐被替代。正如名字中所体现出来的那样，ext3fs 是对ext2fs 的扩展和改善。通过增加日志功能，ext3fs大大增加了文件系统的可靠性。
        日志功能是基于灾难恢复的需求而诞生的。ext3fs 文件系统预留了一块专门的区域来保存日志文件，当对文件进行写操作的时候，所有的修改将首先写入日志文件，随后再写入一条记录标记日志项的结束。完成以上这些操作之后，才会对文件系统作实际的修改。这样当系统崩溃后(Linux 上并没有祖传蓝屏)，就可以利用日志恢复文件系统，在最大程度上避免了数据的丢失。
        值得一提的是，所有这些检查都是自动完成的。日志机制检查每个文件系统所需的时间为1秒，这意味着灾难恢复几乎不耽误任何时间。

      ReiserFS 文件系统
        ReiserFS 是另一种在Linux 上广泛使用的文件系统。相比前面介绍的两种，ReiserFS 是一个非常年轻的文件系统。和ext3fs 一样它也是一种日志文件系统，从而免去了对系统崩溃、意外断电等特殊事件的担忧。除此之外，ReiserFS 还加入了模块化的文件系统接口，这个功能对于开发人员和系统管理员比较有用，它还可以在特殊环境增强文件安全性。

      有关 swap(交换分区)
        这是一块特殊的硬盘空间，当狮叽内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，放在交换分区中，从而为当前运行的程序腾出足够的内存空间，实际上就是缓存盘。这种"拆东墙，补西墙"的方式几乎被应用于几乎所有的操作系统，其显著的优点是通过系统的调度，应用程序实际可以使用的内存空间将远远超过物理内存。由于硬盘空间的价格比RAM 低得多，因此这种方式是非常经济和实惠的。当然，频繁地读写硬盘会显著降低系统的运行速度，这是使用交换分区最大的限制。(实际上现在出现了内存太大用不完的情况，通过RAMDISK技术解决，另外随着新一代U.2接口、PCIe 接口固态硬盘和先进的NVMe标准协议的出现，其理论读写速度已经能够超过老一代的DDR3内存了，而且目前消费级内存的价格普遍跳水，这让swap创立的初衷在未来处于一种比较尴尬地位)
        相比较而言，Windows 不会为swap 单独划分一个分区，而是使用分页文件实现相同的功能。在概念上Windows 称之为"虚拟内存"。
        具体要使用多大的swap 分区取决于物理内存的大小，也取决于个人的使用情况。

      挂载文件系统(一般都能够自动识别，这里介绍手动挂载光盘)
        $sudo mkdir /mnt/cdrom //创建一个用于挂载的目录
        $sudo mount /dev/cdrom /mnt/cdrom //挂载至刚才新建的目录
        mount: 块设备 /dev/scd0 写保护，以只读方式挂载
        $sudo umount /dev/cdrom //卸载光盘
        /*
          "mount"命令可以挂载文件系统，而在大部分情况下需要使用root 权限运行它。在使用该命令是也可以使用"-t"选项，明确指明设备所使用的文件系统类型
          如果不指明类型，"mount"会自动检测设备上的文件系统，并进行相应的挂载，因此在大多数情况下"-t"是不必要的。以下是常用文件系统的表示方法：
            ext2     //Linux 的ext2fs 文件系统
            ext3     //Linux 的ext3fs 文件系统
            vfat     //Windows 的FAT16/FAT32 文件系统
            ntfs     //Windows 的NTFS 文件系统
            iso9660  //CD-ROM光盘的标准文件系统
          另外两个常用的选项是"-r"和"-w"，分别指定只读模式和可读写模式挂载设备。其中"-w"选项是默认模式。当用户处于安全考虑，不希望被挂载设备上的数据能够改写时，那么"-r"选项是十分有用的
        */

        在启动的时候挂载文件系统(一些东西在之前讲挂载的时候讲过，这里当作复习和深化)
          "/etc/fstab"
          Linux 通过配置"fstab"文件来确定这些信息，这个配置文件对于所有用户可读，但是只有root 用户有修改该文件的操作权限。这里重复提一下fstab 表的各个纵列的依次表示:
            用来挂装每个文件系统的UUID(用于指代设备名)  //UUDI(Universally Unique Identifier 通用唯一标识符)由计算机自动生成一个128位比特的十六进制数字。有些发行版(例如openSUSE)用设备文件的绝对路径替代
            挂载点
            文件系统类型
            各种挂载参数  //注意如果是光盘等移动储存设备的话最后一行参数应该有"exec"，这个参数允许任何人运行该设备上的程序，否则用户不得不一次次求助于管理员，原因可能只是无法启动自己光盘上的程序
            备份频度(用于设置备份的频繁度)
            在重启动过程中文件系统的检查顺序

          这里列出几个常用选项，这些选项也可以紧跟在"mount"的"-o"参数后面使用
            auto  //开机自动挂载
            default,noauto  //开机不自动挂载
            nouser  //只有root 可挂载
            ro  //只读挂载
            rw  //可读写挂载
            user  //任何用户都可以挂载

        为什么无法弹出光盘:卸载文件系统
          在没有使用"umount"命令卸载文件系统之前，按下光驱面板上的出仓按钮是不会有任何反应的，因为此时光盘可能正忙，而弹出设备可能导致数据丢失，作为一款服务器级别的操作系统，Linux 绝不允许这样不负责任的事情发生。另外一个可能用到的参数是"-r"，这个参数指导"umount"在无法卸载文件系统的情况下，尝试以制度方式重新载入。下面为举例:
            $sudo umount -r /dev/sda1
            umount: /dev/sda1 正忙 - 已用只读方式重新挂载
          文件系统只有在没有被使用的情况下才可以被卸载。
          在当前目录是被挂载设备所在目录时，即便没有对该设备任何的读写，写在也是不被允许的。这也是为何之前在演示卸载光盘的时候要退回到其它目录的原因。

      Linux 下设备的表示方法
        Linux 下所有的设备都是被当作文件来操作，现在大部分发行版都利用图形界面有意掩盖了这个事实，实际上只是为了使新手用户更容易理解和操作，尤其是原本的Windows 用户。
        在Linux中，每个设备都被映射为一个特殊文件，这个文件被称作"设备文件"，所有对这个设备的操作都是通过读写这个设备实现的。Linux 把所有设备文件都放在"/dev"目录下。其中大多数是块设备。

    查看磁盘使用情况("df")
      使用命令后会列出"文件系统(可能是绝对路径也可能是UUID)"、"1K-块"、"已用空间"、"可用空间"、"已用%"、"挂载点"等信息。

      实际上"df"命令中会包含很多"无用"的信息。像varrun(内存？) 这样的文件系统，是处于特殊用途而挂载的，而这些信息对于普通用户而言往往没有太大的价值(普通用户往往关心磁盘的使用量)，所以"df"命令提供了"-t"参数用于显示特定的文件系统

    检查和修复文件系统("fsck" file system check)
      正如在介绍ext3fs 和ReiserFS 时所提到的，文件系统在系统发生异常(如电源失效、内核崩溃)时会产生不一致。对于小的损坏，"fsck"命令可以很好地检查问题。特别对于ext3fs 和ReiserFS 这样的日志文件系统，"fsck"可以非常快速的执行检查，并且将日志回滚到上一次正常的状态中。"fsck"接受分区编号(如/dev/sda1)来指定需要检查的文件系统。带有"-p"选项的"fsck"命令会读取fstab 文件来确定检查哪些文件系统，并通过每一条记录最后一个字段所指定的顺序，对文件系统按照数字的升序进行检查。如果两个文件系统的序号相同，那么"fsck"会同时检查她们，在通常情况下，"fsck -p"会在硬盘启动时自动运行。

      注意，在使用"fsck"检查并修复文件系统是存在风险的，特别是当磁盘错误非常严重的时候。因此当一个受损文件系统中包含了非常有价值的数据时，务必首先进行备份。

    在磁盘上建立文件系统("mkfs")
      所有的磁盘在使用前都必须经过格式化。格式化就是在目标盘上建立文件系统的过程。在Linux 下"mkfs"命令用于完成这个操作。当然"mkfs"本身并不执行建立文件系统的工作，而是调用相关的程序。这些程序包括mkdosfs、mke2fs、mkfs.minix 等。通过使用"-t"参数指定文件系统，"mkfs"会调用特定的程序对磁盘进行格式化。
      //新版本的Linux 操作系统可以不带"-t"选项
        minix //Linux 最早期使用的文件系统
        ext2  //Linux 默认文件系统ext2
        ext3  //ext3 文件系统
        msdos //FAT 文件系统
      下面的命令将第2块硬盘的第1个分区(sdb1)格式化为ext3 格式
        $sudo mkfs -t ext3 /dev/sdb1
      另外可以用"-c"选项来检查设备商损坏的块
      //如果硬盘分区已经挂载到文件系统中，那么在格式化之前必须使用"umount"卸载分区
      //另外U 盘设备在Linux 中被认为是SCSI 设备，并且会被识别为第一个没有被硬盘占用的SCSI 设备，也就是说使用"lsusb"命令也可以发现USB 设备，并且编号为所有硬盘的后一位

    压缩
      压缩文件："gzip"
        "gzip"的使用非常方便，只要简单地在"gzip"命令后更上一个想要压缩的文件作为参数就可以了。在默认的情况下，"gzip"命令会给被压缩的文件加上一个"gz"扩展名。如果要解压".gz"文件可以使用"gunzip"命令或者带"-d"选项的"gzip"命令。应该保证需要解压的文件有合适的扩展名。"gzip"支持的扩展名有".gz"、".Z"、"-gz"、".z"、"-z"和"z"。"gzip"也提供了"-l"选项用于查看压缩效果，"-t"命令测试压缩文件完整性，如果文件正常则不会给出任何显示，如果一定要显示结果的话可以使用"-tv"选项。当然在这里提供一个更高压缩率的工具"bzip2"，它可以提供更高的压缩率，但是这是以压缩速度为代价的。不过伴随着摩尔定律惊人的持续性，这种速度上的劣势将变得越来越难以察觉。所以后来"bzip2"以及类似的压缩算法也流行起来。而它的解压方法是"bunzip2"或者"-d"选项。其可识别的压缩文件包格式包括".bz2"、".bz"、".tbz2"、".tbz"和"bzip2"，同样可以使用"-tv"选项检查压缩文件的完整性。
  }
}
